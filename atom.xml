<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Proud Soul</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.theproudsoul.cn/"/>
  <updated>2019-05-20T00:55:03.148Z</updated>
  <id>http://www.theproudsoul.cn/</id>
  
  <author>
    <name>Layla Zheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用OpenVPN来构建VPN</title>
    <link href="http://www.theproudsoul.cn/2019/openvpn/"/>
    <id>http://www.theproudsoul.cn/2019/openvpn/</id>
    <published>2019-05-15T04:56:35.000Z</published>
    <updated>2019-05-20T00:55:03.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>外网客户端与内网数据服务器均加入一个<strong>虚拟局域网</strong>，并使用该虚拟网赋予的 IP 地址，解决服务器<strong>可见性</strong>问题</p><ul><li>IP隧道技术</li><li>保留IP地址：10.8.0.0/24</li></ul><p>还有<strong>通信安全</strong>问题，专用网</p><ul><li>SSL/TLS、IPSec等等</li></ul><h2 id="使用OpenVPN来构建VPN"><a href="#使用OpenVPN来构建VPN" class="headerlink" title="使用OpenVPN来构建VPN"></a>使用<a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a>来构建VPN</h2><ul><li>OpenVPN 使用 IP 隧道技术构建 VLAN</li><li>OpenVPN 使用数字证书与 SSL/TLS 技术实现通信安全（基于数字证书的双向认证）</li><li>必须构建一个 <strong>PKI 系统</strong></li></ul><h2 id="环境和相关命令"><a href="#环境和相关命令" class="headerlink" title="环境和相关命令"></a>环境和相关命令</h2><ul><li><a href="www.vultr.com">Vultr</a> 服务器 和 <em>Ubuntu 18.04 x64</em> 的操作系统，需要设置 UDP 1194端口 的防火墙规则为accept</li><li>使用 <a href="www.putty.org">PuTTY</a> 进行远程连接</li><li>使用 WinSCP 传输文件</li><li>源文件全部放在 /usr/local/src 下，配置文件等全部放在 /usr/local/data 下</li></ul><p>PuTTY容易断开连接，所以在登录时在Connection处设置keepalive 10s，并勾选下面两个勾</p><ul><li>wget [url] 命令用来在Linux环境下载文件</li><li>tar -zxvf [文件名] 解压 .tgz文件和  .tar.gz 文件</li><li>gzip -d [文件名] 用来解压 .gz 文件</li><li>ps -ef 用来查看进程（ps -ef | grep openvpn 过滤出openvpn相关进程）</li><li>kill -s 9 [pid] 用来杀死某个pid的进程</li><li>cat 查看文件内容</li><li>nano 查看并修改文件内容</li></ul><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><ol><li>使用EasyRSA构建一个PKI系统</li><li>为openvpn服务器和客户端生成证书</li><li>下载openvpn</li><li>修改server.conf文件作为服务器端配置文件</li><li>修改client.conf文件作为客户端配置文件</li><li>运行并测试</li></ol><h2 id="构建PKI系统"><a href="#构建PKI系统" class="headerlink" title="构建PKI系统"></a>构建PKI系统</h2><h3 id="下载-EasyRSA-3"><a href="#下载-EasyRSA-3" class="headerlink" title="下载 EasyRSA 3"></a>下载 <a href="https://github.com/OpenVPN/easy-rsa" target="_blank" rel="noopener">EasyRSA 3</a></h3><p>选择安装目录，可以是任何目录，本文选定的是/usr/local/src，下载完成后文件夹更名为easyrsa（更名步骤可无视）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line"></span><br><span class="line">wget https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.6/EasyRSA-unix-v3.0.6.tgz</span><br><span class="line">tar -zxvf EasyRSA-unix-v3.0.6.tgz</span><br><span class="line">mv EasyRSA-v3.0.6 easyrsa</span><br></pre></td></tr></table></figure><h3 id="构建一个-PKI-和-CA"><a href="#构建一个-PKI-和-CA" class="headerlink" title="构建一个 PKI 和 CA"></a>构建一个 PKI 和 CA</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd easyrsa/</span><br><span class="line"></span><br><span class="line">./easyrsa init-pki</span><br><span class="line">./easyrsa build-ca</span><br></pre></td></tr></table></figure><p>然后按提示设置一个CA密码，这个密码在后面为数字证书签名的时候要用到<br>然后会看到设置CA的Common Name就完成了，可以看到以下提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Common Name (eg: your user, host, or server name) [Easy-RSA CA]:</span><br><span class="line"></span><br><span class="line">CA creation complete and you may now import and sign cert requests.</span><br><span class="line">Your new CA certificate file for publishing is at:</span><br><span class="line">/usr/local/src/easyrsa/pki/ca.crt</span><br></pre></td></tr></table></figure><h3 id="准备公钥和密钥"><a href="#准备公钥和密钥" class="headerlink" title="准备公钥和密钥"></a>准备公钥和密钥</h3><p>OpenVPN系统需要准备以下文件（以下服务器指openvpn服务器，客户端指意图通过openvpn通信的机器）</p><table><thead><tr><th>文件名</th><th>使用者</th><th>说明</th><th>保密</th></tr></thead><tbody><tr><td>ca.crt</td><td>所有人</td><td>根证书</td><td>否</td></tr><tr><td>ca.key</td><td>签发私钥的机器</td><td>根私钥</td><td>是</td></tr><tr><td>dh{n}.pem</td><td>服务器</td><td>Diffie Hellman parameters</td><td>否</td></tr><tr><td>server.crt</td><td>服务器</td><td>服务器证书</td><td>否</td></tr><tr><td>server.key</td><td>服务器</td><td>服务器私钥</td><td>是</td></tr><tr><td>client(s).crt</td><td>服务器</td><td>客户端证书</td><td>否</td></tr><tr><td>client(s).key</td><td>服务器</td><td>客户端私钥</td><td>是</td></tr></tbody></table><p>需要注意的点：</p><ul><li>最佳实践是在需要这些文件的机器上生成req文件和key文件，然后将req文件传送到CA，由CA进行签证后将crt证书发回。（考虑到传送通道安全性，生成key和crt后再传送这两个文件这种方式的安全性无法保证）</li><li>可以多个客户端共同使用一个证书和私钥，但最好的不同的客户端使用不同的。</li><li>为了传输方便，直接在服务器端使用命令 ./easyrsa gen-dh 生成dh.pem文件</li></ul><p>如果是在不同的机器（或文件夹）生成证书和私钥，EntityName可以自定义，本例子使用server代表openvpn服务器，forwin 代表一个使用 Windows 10 系统的客户端<br>中间根据提示设置密码和 Common Name</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa init-pki</span><br><span class="line">./easyrsa gen-req EntityName</span><br></pre></td></tr></table></figure><p>然后将 .req 文件发送到CA所在机器，然后导入到CA系统(如果是直接在CA系统处生成证书，省略此步骤)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa import-req /tmp/path/to/import.req EntityName</span><br></pre></td></tr></table></figure><p>然后为 server 签订服务器证书为 forwin 签订客户端证书<br>中间根据提示输入“yes”和 CA 的密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./easyrsa sign-req server server</span><br><span class="line">./easyrsa sign-req client forwin</span><br></pre></td></tr></table></figure><p>成功后可以看到以下提示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The Subject's Distinguished Name is as follows</span><br><span class="line">commonName            :ASN.1 12:'server'</span><br><span class="line">Certificate is to be certified until Apr 26 03:11:56 2022 GMT (1080 days)</span><br><span class="line"></span><br><span class="line">Write out database with 1 new entries</span><br><span class="line">Data Base Updated</span><br><span class="line"></span><br><span class="line">Certificate created at: /usr/local/src/easyrsa/pki/issued/server.crt</span><br></pre></td></tr></table></figure><p>然后将 .crt 文件发给对应机器待用就好了</p><h2 id="配置OpenVPN"><a href="#配置OpenVPN" class="headerlink" title="配置OpenVPN"></a>配置OpenVPN</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>上<a href="https://openvpn.net/community-downloads/" target="_blank" rel="noopener">官网</a>对应操作系统下载和安装<br>Ubuntu直接使用以下命令安装和查看版本，Windows系统下载exe文件然后安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install openvpn</span><br><span class="line">openvpn --version</span><br></pre></td></tr></table></figure><p>在/usr/local/data夹下创建一个openvpn文件夹存放相关证书和配置文件，将证书文件传送过来，将示例server.conf和client.conf文件复制过来。（或者在<a href="https://github.com/OpenVPN/openvpn/tree/master/sample/sample-config-files" target="_blank" rel="noopener">这里</a>下载）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/data</span><br><span class="line">mkdir openvpn</span><br><span class="line">cd openvpn</span><br><span class="line"></span><br><span class="line">cp /usr/local/src/easyrsa/pki/ca.crt ./</span><br><span class="line">cp /usr/local/src/easyrsa/pki/issued/server.crt ./</span><br><span class="line">cp /usr/local/src/easyrsa/pki/private/server.key ./</span><br><span class="line">cp /usr/local/src/easyrsa/pki/dh.pem ./dh2048.pem</span><br><span class="line">openvpn --genkey --secret ta.key</span><br><span class="line"></span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz ./</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf ./</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">openvpn server.conf</span><br></pre></td></tr></table></figure><p>此时已经在服务器开启了<strong>openvpn服务</strong><br><img src="http://ww1.sinaimg.cn/large/7b19d4ddly1g32bkdqjd1j20ml0syq6k.jpg" alt="openvpn服务开启"></p><p>使用 <strong>WinSCP</strong> 之类软件在客户端凑齐以下文件</p><ul><li>ca.crt</li><li>forwin.crt</li><li>forwin.key</li><li>ta.key</li><li>client.conf</li></ul><p>然后修改 <strong>client.conf</strong> 并将其更名为 <strong>client.ovpn</strong>，修改部分参数，内容如下（仅作参考，路径自行设置，记得做双反斜杠和双引号处理），0.0.0.0 处改为你的<strong>服务器公网IP</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">remote 0.0.0.0 1194</span><br><span class="line">ca "C:\\Users\\only-\\Documents\\ca.crt"</span><br><span class="line">cert "C:\\Users\\only-\\Documents\\forwin.crt"</span><br><span class="line">key "C:\\Users\\only-\\Documents\\forwin.key"</span><br><span class="line">tls-auth "C:\\Users\\only-\\Documents\\ta.key" 1</span><br></pre></td></tr></table></figure><p>打开 <strong>OpenVPN GUI</strong> 右键导入配置文件<strong>client.opvn</strong><br><img src="http://ww1.sinaimg.cn/large/7b19d4ddly1g32bjkey2cj21ha0syae6.jpg" alt="客户端成功连接"></p><p>ping 一下试试看<br><img src="http://ww1.sinaimg.cn/large/7b19d4ddly1g32bortfrjj20jh0b2my9.jpg" alt="客户端ping通服务器"><br><img src="http://ww1.sinaimg.cn/large/7b19d4ddly1g32bo82lzzj20mu0ed0u3.jpg" alt="服务器ping通客户端"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我遇到了客户端成功“Initialization Sequence Completed”的信息但是ping不通，然后在服务器加了下面这个命令，同时本机电脑也应注意防火墙问题</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p udp --dport 1194 -j ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h2&gt;&lt;p&gt;外网客户端与内网数据服务器均加入一个&lt;strong&gt;虚拟局域网&lt;/strong&gt;，并使用该虚拟网赋予的 IP 地址，解决服务器&lt;strong
      
    
    </summary>
    
      <category term="Security" scheme="http://www.theproudsoul.cn/categories/Security/"/>
    
    
  </entry>
  
  <entry>
    <title>STP生成树协议</title>
    <link href="http://www.theproudsoul.cn/2019/stp/"/>
    <id>http://www.theproudsoul.cn/2019/stp/</id>
    <published>2019-05-13T06:22:24.000Z</published>
    <updated>2019-05-15T14:40:06.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><ol><li>二层链路没有冗余——网络存在单点 / 单线路故障</li><li>网络的冗余性增强——出现二层环路</li><li>环路带来的问题：广播风暴；多帧复制；MAC表紊乱</li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>生成树协议 (STP) 是在网桥和交换机上运行的第二层协议。</li><li>STP 的规范是 IEEE 802.1D。</li><li>STP 的主要目的是确保冗余的网络拓扑结构中出现环路。</li><li>为了提供此所需的路径冗余以及避免出现环路情况，STP 定义了一个跨越扩展网络中所有交换机的树。</li><li>STP 强制某些冗余数据路径处于备用（阻塞）状态，而使其他路径处于转发状态。</li><li>如果处于转发状态的链路不可用，则 STP 会通过激活相应的备用路径来重新配置网络及重新路由数据路径。</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g3055qy4lpg20fp04p3ya.gif" alt><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g3055xbwdag20fo04m3ya.gif" alt></p><p><a href="https://www.cisco.com/c/en/us/support/docs/lan-switching/spanning-tree-protocol/5234-5.html" target="_blank" rel="noopener">生成树协议 (STP)</a></p><h2 id="STP的操作"><a href="#STP的操作" class="headerlink" title="STP的操作"></a>STP的操作</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><ol><li>每个交换网络选举一个根桥RB(Root Bridge)</li><li>每个非根桥上选举一个根端口RP(Root Port)</li><li>每个段选举一个指定端口DP(Designated Port)</li><li>阻塞非指定端口NDP</li></ol><h3 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h3><blockquote><p><u>BPDU Bridge Protocol Data Unit 网桥协议数据单元</u></p><p>所有交换机都将交换用于根交换机选择和网络后续配置的信息。网桥协议数据单元 (BPDU) 传播此信息。每台交换机都会将它发送给相邻交换机的 BPDU 中的参数与它从相邻交换机接收的 BPDU 中的参数进行比较。</p></blockquote><table><thead><tr><th>字节</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>2</td><td>协议</td><td>代表上层协议（BPDU），该值总为0</td></tr><tr><td>1</td><td>版本</td><td>（802.1D的总为0）</td></tr><tr><td>1</td><td>TYPE</td><td>“配置BPDU”为0、“TCN BPDU”为80</td></tr><tr><td>1</td><td>标志</td><td>LSB最低有效位表示TC标志；MSB最高有效位表示TCA标志</td></tr><tr><td>8</td><td>根桥ID</td><td>根网桥的桥ID</td></tr><tr><td>4</td><td>路径开销</td><td>到达根桥的STP cost</td></tr><tr><td>8</td><td>网桥ID</td><td>BPDU发送桥的ID（桥优先级+桥MAC地址）</td></tr><tr><td>2</td><td>端口ID</td><td>BPDU发送网桥的端口ID（优先级+端口号）</td></tr><tr><td>2</td><td>消息寿命<br>Message age</td><td>从根网桥发出BPDU之后的秒数，每经过一个网桥都减1，所以它本质上是到达根桥的跳数。</td></tr><tr><td>2</td><td>最大寿命<br>Max age</td><td>当一段时间未收到任何BPDU，生存期到达MAX age时，网桥认为该端口连接的链路发生故障。默认20S</td></tr><tr><td>2</td><td>Hello时间</td><td>根网桥连续发送的BPDU之间的时间间隔。默认2S</td></tr><tr><td>2</td><td>转发延迟</td><td>在监听和学习状态所停留的时间间隔。默认15S</td></tr></tbody></table><h3 id="STP接口Cost与接口带宽的对应关系"><a href="#STP接口Cost与接口带宽的对应关系" class="headerlink" title="STP接口Cost与接口带宽的对应关系"></a>STP接口Cost与接口带宽的对应关系</h3><blockquote><p>路径开销是接口cost累加，而接口cost是基于接口带宽的</p></blockquote><table><thead><tr><th>Link Speed</th><th>Cost</th></tr></thead><tbody><tr><td>10 Gb/s</td><td>2</td></tr><tr><td>1 Gb/s</td><td>4</td></tr><tr><td>100 Mb/s</td><td>19</td></tr><tr><td>10 Mb/s</td><td>100</td></tr></tbody></table><p>非根桥某个接口到RB的路径开销等于该接口的Cost加上这个接口收到的BPDU中包含的Path Cost值。</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30mc6v24mj20kk06dq3s.jpg" alt></p><h3 id="1-每个交换网络选举一个根桥RB"><a href="#1-每个交换网络选举一个根桥RB" class="headerlink" title="1 每个交换网络选举一个根桥RB"></a>1 每个交换网络选举一个根桥RB</h3><blockquote><p>使用STP，关键是为在选择成为在网络的重要的根网桥的网络的所有交换机。网络中的所有其他决策（例如，要阻塞哪个端口以及要使哪个端口处于转发模式）都是从此根网桥的角度做出的。</p></blockquote><ul><li>Bridge Identifier，交换机的STP标识符；</li><li>拥有最小BID的交换机成为根桥。</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30l72j0oij20ii06kmxv.jpg" alt></p><h3 id="2-每个非根桥上选举一个根端口RP"><a href="#2-每个非根桥上选举一个根端口RP" class="headerlink" title="2 每个非根桥上选举一个根端口RP"></a>2 每个非根桥上选举一个根端口RP</h3><p>比较顺序：</p><ol><li>根桥ID</li><li>到根桥的路径开销</li><li>网桥ID</li><li>端口ID</li></ol><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30m79ofr3j20cv07cwez.jpg" alt></p><p>Port ID</p><ul><li>Port Identifier，接口标识符，共有2个字节。</li><li>Port ID （2字节）= 接口优先级（1字节）+接口编号（1字节）。</li><li>缺省情况下接口优先级为128，范围是0-255。</li></ul><h3 id="3-每个段选举一个指定端口DP"><a href="#3-每个段选举一个指定端口DP" class="headerlink" title="3 每个段选举一个指定端口DP"></a>3 每个段选举一个指定端口DP</h3><p>比较顺序（均比小）：</p><ol><li>到根桥的路径开销</li><li>网桥ID</li><li>端口ID</li></ol><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30m5vvvmbj20cz078mxq.jpg" alt></p><h3 id="4-阻塞非指定端口NDP"><a href="#4-阻塞非指定端口NDP" class="headerlink" title="4 阻塞非指定端口NDP"></a>4 阻塞非指定端口NDP</h3><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30m4r5hpjj20cx0743z3.jpg" alt></p><h2 id="STP的端口状态"><a href="#STP的端口状态" class="headerlink" title="STP的端口状态"></a>STP的端口状态</h2><table><thead><tr><th style="text-align:center">端口状态</th><th style="text-align:center">端口能力</th></tr></thead><tbody><tr><td style="text-align:center">Disabled</td><td style="text-align:center">不收发任何报文</td></tr><tr><td style="text-align:center">Blocking<br>(loss of BPDU detected)<br>(max age = 20 sec)</td><td style="text-align:center">不接收或者转发数据，接收但不发送BPDU，不进行地址学习</td></tr><tr><td style="text-align:center">Listening<br>(forward delay = 15 sec)</td><td style="text-align:center">不接收或者转发数据，接收并发送BPDU，不进行地址学习</td></tr><tr><td style="text-align:center">Learning<br>(forward delay = 15 sec)</td><td style="text-align:center">不接收或者转发数据，接收并发送BPDU，开始进行地址学习</td></tr><tr><td style="text-align:center">Forwarding</td><td style="text-align:center">接收或者转发数据，接收并发送BPDU，进行地址学习</td></tr></tbody></table><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g30m8dypucj20h90cwjsh.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二层链路没有冗余——网络存在单点 / 单线路故障&lt;/li&gt;
&lt;li&gt;网络的冗余性增强——出现二层环路&lt;/li&gt;

      
    
    </summary>
    
      <category term="交换基础" scheme="http://www.theproudsoul.cn/categories/%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="链路协议" scheme="http://www.theproudsoul.cn/tags/%E9%93%BE%E8%B7%AF%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>VLAN</title>
    <link href="http://www.theproudsoul.cn/2019/VLAN/"/>
    <id>http://www.theproudsoul.cn/2019/VLAN/</id>
    <published>2019-05-13T00:49:23.000Z</published>
    <updated>2019-05-14T01:42:23.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><ul><li>交换机的所有接口属于一个广播域，往往也是一个逻辑子网；</li><li>用户无法根据业务需要灵活的在交换机上进行广播域的隔离；</li><li>随着网络规模越来越大、数量越来越多，广播风暴将给网络带来重大问题；</li><li>VLAN（Virtual LAN）技术提供了一种灵活的解决方案；</li><li>将交换机的接口根据业务需要添加到不同的VLAN中，从而实现二层隔离。</li></ul><h2 id="VLAN的成员模式"><a href="#VLAN的成员模式" class="headerlink" title="VLAN的成员模式"></a>VLAN的成员模式</h2><ul><li>静态VLAN——以手工的方式将接口加入特定的VLAN</li><li>动态VLAN——根据接入到交换机的客户端的MAC地址等信息，动态地将交换机的接口添加到特定的VLAN</li></ul><h2 id="VLAN知识点小结"><a href="#VLAN知识点小结" class="headerlink" title="VLAN知识点小结"></a>VLAN知识点小结</h2><ul><li>一个VLAN中所有设备处于同一广播域内，不同的VLAN为不同的广播域，一个VLAN一般是一个IP网段，不同的VLAN规划到不同的IP网段；</li><li>不同的VLAN之间二层隔离，广播不能跨越VLAN传播，因此不同VLAN之间的设备无法进行二层通信，需通过三层设备实现互通；</li><li>VLAN中成员关系多基于交换机的接口进行静态地分配，划分VLAN就是将交换机的接口添加到特定VLAN；</li><li>VLAN工作于OSI参考模型的第二层，是二层交换机的一个非常根本的工作机制。</li></ul><h2 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h2><p><a href="https://www.cisco.com/c/en/us/support/docs/lan-switching/8021q/17056-741-4.html" target="_blank" rel="noopener">交换机间链路和IEEE 802.1Q帧格式</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Trunk用于运载属于在设备之间的<u>多个VLAN</u>在<u>同一条链路</u>的数据流；</li><li>Trunk链路两端的交换机需采用相同的干道协议（Dot1q或ISL）；</li><li>Trunk技术使得VLAN能够跨交换机，Trunk链路两端的接口需指定为Trunk类型。</li></ul><h3 id="ISL协议（CISCO）"><a href="#ISL协议（CISCO）" class="headerlink" title="ISL协议（CISCO）"></a>ISL协议（CISCO）</h3><blockquote><p>交换链路内协议</p></blockquote><ul><li>CISCO私有封装协议，通过硬件（ASIC）实现</li><li>在交换机或路由器与交换机之间，在交换机与具有ISL网卡的服务器之间可以实现</li><li>在 ISL 中，原始帧将经过封装，另外添加一个报头，然后通过中继链接进行传输。在接收端，去除报头，并且帧被传送到分配的VLAN。</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2zufainw0j20n907iaam.jpg" alt></p><h3 id="802-1Q"><a href="#802-1Q" class="headerlink" title="802.1Q"></a>802.1Q</h3><ul><li>802.1q是一种公有标准，也称为Dot1q</li><li>在 802.1Q 中，中继设备会在原始帧中插入一个 4 字节的标记，重新计算帧校验序列 (FCS)，然后通过中继链路发送帧。在接收端，去除标记，并且帧被传送到分配的VLAN。</li><li>802.1Q 不标记<strong>本地 VLAN</strong> 上的帧。它将标记在中继上传输及接收的所有其他帧。配置 802.1Q 中继时，必须确认在中继两端配置了相同的本地 VLAN。</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g302n5za7wj20lz0alwfj.jpg" alt></p><h2 id="VLAN的配置"><a href="#VLAN的配置" class="headerlink" title="VLAN的配置"></a>VLAN的配置</h2><h3 id="Access接口"><a href="#Access接口" class="headerlink" title="Access接口"></a>Access接口</h3><ul><li>Access是交换机二层接口的一种类型，通常用于连接终端（例如PC或服务器）或路由器；</li><li>Access接口只能加入一个VLAN，默认交换机上的二层接口都加入VLAN1。</li></ul><h3 id="VLAN的基本配置"><a href="#VLAN的基本配置" class="headerlink" title="VLAN的基本配置"></a>VLAN的基本配置</h3><ul><li><p>创建VLAN信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Switch(config)#</span><span class="bash"> vlan 2</span></span><br><span class="line"><span class="meta">Switch(config-vlan)#</span><span class="bash"> name TechDept</span></span><br></pre></td></tr></table></figure></li><li><p>配置Access模式的接口用于连接终端设备，并且将接口加入特定VLAN</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Switch(config)#</span><span class="bash"> interface fa0/1</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"> switchport mode access</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"> switchport access vlan 2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Trunk的基本配置"><a href="#Trunk的基本配置" class="headerlink" title="Trunk的基本配置"></a>Trunk的基本配置</h3><ul><li><p>配置Trunk封装方式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Switch(config)#</span><span class="bash"> interface fa0/15</span></span><br><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"> switchport trunk encapsulation &#123;isl | dot1q | negotiate&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>开启端口Trunk模式</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Switch(config-if)#</span><span class="bash"> switchport mode &#123;dynamic &#123;auto | desirable&#125; | trunk&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用路由器子接口实现VLAN间互访"><a href="#使用路由器子接口实现VLAN间互访" class="headerlink" title="使用路由器子接口实现VLAN间互访"></a>使用路由器子接口实现VLAN间互访</h3><ul><li>在路由器上基于物理接口来创建子接口，通过子接口与VLAN对接，子接口是<u>逻辑接口</u>，物理上并不存在</li><li>子接口能够识别打上Tag的数据帧</li><li>路由器子接口也被形象地称为“单臂路由”</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g302uo8565j20oz0e1ac0.jpg" alt></p><h2 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h2><p>Switch Virtual Interfaces（SVI）</p><p>VLAN广播包block（一个交换机有其中一个接口属于VLAN10，不让这个接口的广播包往其他接口泛洪）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术背景&quot;&gt;&lt;a href=&quot;#技术背景&quot; class=&quot;headerlink&quot; title=&quot;技术背景&quot;&gt;&lt;/a&gt;技术背景&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;交换机的所有接口属于一个广播域，往往也是一个逻辑子网；&lt;/li&gt;
&lt;li&gt;用户无法根据业务需要灵活的在交换机上进
      
    
    </summary>
    
      <category term="交换基础" scheme="http://www.theproudsoul.cn/categories/%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>二层交换基础</title>
    <link href="http://www.theproudsoul.cn/2019/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.theproudsoul.cn/2019/二层交换基础/</id>
    <published>2019-05-13T00:20:54.000Z</published>
    <updated>2019-05-13T15:52:56.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="园区网中的二层交换"><a href="#园区网中的二层交换" class="headerlink" title="园区网中的二层交换"></a>园区网中的二层交换</h2><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2zrpqzvdsj20mo0gfdj0.jpg" alt></p><h2 id="二层交换机的主要功能"><a href="#二层交换机的主要功能" class="headerlink" title="二层交换机的主要功能"></a>二层交换机的主要功能</h2><ul><li>终端设备的接入</li><li>学习MAC地址，并维护MAC地址表</li><li>以太网数据帧的交换，根据目的MAC地址转发数据帧</li><li>防止二层环路</li></ul><h2 id="MAC地址的概念"><a href="#MAC地址的概念" class="headerlink" title="MAC地址的概念"></a>MAC地址的概念</h2><ul><li>MAC地址有48位，通常被表示为点分十六进制数；</li><li>MAC地址全球唯一，由 IEEE对OUI进行管理和分配；</li><li>每个地址由两部分组成，分别是供应商代码和序列号。其中前24位二进制代表该供应商代码。剩下的24位由厂商自己分配。</li><li>地址表</li></ul><h2 id="二层交换机的寻址及数据交换"><a href="#二层交换机的寻址及数据交换" class="headerlink" title="二层交换机的寻址及数据交换"></a>二层交换机的寻址及数据交换</h2><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g304dhsu6ij20lq04y74w.jpg" alt></p><ol><li><p>初始情况下交换机的MAC地址表是空的</p></li><li><p>PC1发送一个数据帧给PC4，暂且假设PC1已经知道PC4的MAC地址。</p></li><li><p>交换机在收到数据帧后，将数据帧的源MAC地址学习到 MAC地址表中，并与接收该帧的接口FE0/1口关联。</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g304hqkgf2j207x02z3yl.jpg" alt></p></li><li><p>交换机在MAC地址表中查询数据帧的目的MAC地址，发现没有匹配的表项，因此将数据帧从除了其入站接口之外的所有接口泛洪出去。</p></li><li><p>PC2及PC3收到数据帧后将其丢弃，因为这些数据帧并非发送给自己；PC4则收下数据帧。现在PC4要回复数据给PC1。</p></li><li><p>交换机收到了数据帧，将帧头中的源MAC地址学习到MAC表中，并与接口F0/4关联。</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g304jmxavgj207l03swep.jpg" alt></p></li><li><p>随后交换机在MAC表中查找数据帧的目的MAC地址，发现有一个匹配的 7 表项，出接口是Fa0/1，于是将数据帧转发到Fa0/1口</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g304kc3ciuj207k03t74h.jpg" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;园区网中的二层交换&quot;&gt;&lt;a href=&quot;#园区网中的二层交换&quot; class=&quot;headerlink&quot; title=&quot;园区网中的二层交换&quot;&gt;&lt;/a&gt;园区网中的二层交换&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7b19
      
    
    </summary>
    
      <category term="交换基础" scheme="http://www.theproudsoul.cn/categories/%E4%BA%A4%E6%8D%A2%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>OSPF</title>
    <link href="http://www.theproudsoul.cn/2019/OSPF/"/>
    <id>http://www.theproudsoul.cn/2019/OSPF/</id>
    <published>2019-05-12T08:27:27.000Z</published>
    <updated>2019-05-13T13:54:42.188Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Open Shortest Path First 开放式最短路径优先协议，是用于分配单个自控系统中的路由信息的内部网关协议。</p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/open-shortest-path-first-ospf/7039-1.html" target="_blank" rel="noopener">CISCO中文文档</a></p><p><a href="https://www.cisco.com/c/en/us/support/docs/ip/open-shortest-path-first-ospf/7039-1.html" target="_blank" rel="noopener">CISCO英文文档</a></p><h2 id="链路状态"><a href="#链路状态" class="headerlink" title="链路状态"></a>链路状态</h2><p>OSPF 是一种<strong>链路状态协议</strong>。我们可以将链路视为路由器的接口。链路状态是对接口及接口与相邻路由器的关系的描述。例如，接口的说明将包括接口的 IP 地址、掩码、所连接的网络的类型、连接到该网络的路由器等。所有这些链路状态的集合形成链路状态数据库。</p><h2 id="OSPF度量"><a href="#OSPF度量" class="headerlink" title="OSPF度量"></a>OSPF度量</h2><p>$$<br>Cost = 参考带宽(10^8) / 接口带宽(b/s)<br>$$</p><ul><li>每个路由器都把自己当做根，并且给予累积成本（Cost值）来计算到达目的地的最短路径。</li><li>在每一个运行OSPF的<strong>接口</strong>上，都维护着一个接口Cost， 接口Cost=100M/接口带宽，其中100M为OSPF的参考带宽值。</li><li>一条路由的Cost由该路由从起源到本路由器沿途所有入站接口的Cost值<strong>累加</strong>。</li></ul><h2 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h2><ul><li>Hello——建立和维护OSPF邻居关系</li><li>DBD——链路状态数据库描述信息（描述LSDB中LSA头部信息）</li><li>LSR——链路状态请求，向OSPF邻居请求链路状态信息</li><li>LSU——链路状态更新（包含一条或多条LSA）</li><li>LSAck——对LSU中的LSA进行确认</li></ul><h2 id="区域与边界路由器"><a href="#区域与边界路由器" class="headerlink" title="区域与边界路由器"></a>区域与边界路由器</h2><ul><li>OSPF 使用泛洪在路由器之间交互链路状态更新。</li><li>路由信息的所有更改都<strong>泛洪给网络中的所有路由器</strong>。</li><li>引入区域是为了给链路状态更新的急剧增长设置边界。</li><li>路由器上的泛洪和 Dijkstra 算法计算限制为<strong>针对区域内的更改</strong>。</li><li>区域之内的所有路由器都有整个区域内部确切的链路状态数据库。</li><li>属于多个区域的路由器以及将这些区域连接到骨干网区域的路由器称为区域边界路由器 (ABR)。</li><li>ABR 必须维护描述骨干网区域和所连接的其他区域的信息。</li><li>区域特定于<u><strong><em>接口</em></strong></u>。所有接口都在同一个区域之内的路由器称为内部路由器 (IR)。接口在多个区域内的路由器称为区域边界路由器 (ABR)。</li><li>在 OSPF 和其他路由协议（IGRP、EIGRP、IS-IS、RIP、BGP、Static）或其他 OSPF 路由进程实例之间用作网关（重分配）的路由器称为自治系统边界路由器 (ASBR)。所有路由器都可以是 ABR 或 ASBR。</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2zppv10rng20bf077a9v.gif" alt></p><h2 id="骨干网与区域-0"><a href="#骨干网与区域-0" class="headerlink" title="骨干网与区域 0"></a>骨干网与区域 0</h2><p>当涉及多个区域时，OSPF 具有特殊限制。如果配置了多个区域，则<u><strong>这些区域中必须有一个是区域 0</strong></u>。此区域称为骨干网。当设计网络时，从区域 0 开始然后扩展到其他区域是很好的做法。</p><p>骨干网必须位于所有其他区域的中心，即所有区域都必须在物理上连接到骨干网。接下来便是 OSPF 要求所有区域都将路由信息注入骨干网，骨干网又将这些信息散发到其他区域。</p><p>下图显示 OSPF 网络中的信息流：</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2zppa4dp9g20as0930sk.gif" alt></p><h2 id="OSPF的三张表"><a href="#OSPF的三张表" class="headerlink" title="OSPF的三张表"></a>OSPF的三张表</h2><ul><li>邻居表——存储了OSPF路由器邻居的状态以及关于该邻居的其他数据。</li><li>拓扑表——OSPF用 <strong>LSA（ Link State Advertisement 链路状态通告）</strong>来描述网络拓扑信息，LSDB中存储着路由器产生或者收到的LSA。</li><li>路由表——基于LSDB进行SPF算法运算，计算得出的路由被加载到路由表中。</li></ul><h2 id="OSPF基本运行步骤"><a href="#OSPF基本运行步骤" class="headerlink" title="OSPF基本运行步骤"></a>OSPF基本运行步骤</h2><ol><li>建立邻接关系（Establish router adjacencies）</li><li>必要的时候进行DR的选举（Elect the DR/BDR）</li><li>发现路由（Discover routes）</li><li>选择合适的路由器（Select appropriate routes）</li><li>维护路由信息（Maintain routing information）</li></ol><h2 id="OSPF网络类型（4种）"><a href="#OSPF网络类型（4种）" class="headerlink" title="OSPF网络类型（4种）"></a>OSPF网络类型（4种）</h2><ul><li>BMA 广播型多路访问</li><li>Point-to-Point 点对点</li><li>NBMA 非广播型多路访问（例如帧中继、X.25、ATM）</li><li>Point-to-MultiPoint 点到多点网络[^1]</li></ul><h2 id="OSPF邻接关系"><a href="#OSPF邻接关系" class="headerlink" title="OSPF邻接关系"></a>OSPF邻接关系</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><p>OSPF使用Hello报文来发现直连链路上的其他OSPF路由器， Hello报文发向组播地址224.0.0.5（ All-OSPF-Routers）</p><p>两台OSPF路由器（的接口）需具备匹配的参数才能够建立起OSPF邻居关系</p></blockquote><ol><li>Hello时间间隔</li><li>Dead时间间隔</li><li>区域编号</li><li>认证（如果启用了认证）</li><li>链路MTU大小</li><li>子网掩码</li><li>子网号</li><li>末梢区域设置</li></ol><h3 id="邻接关系建立过程"><a href="#邻接关系建立过程" class="headerlink" title="邻接关系建立过程"></a>邻接关系建立过程</h3><ol><li><strong>失效状态（Down）：</strong>这是邻居会话的初始状态，表示最近没有从邻居收到信息。</li><li><strong>尝试状态（Attempt）：</strong>该状态仅仅适用于连接在NBMA网络上的邻居。该</li><li><strong>初始状态（Init）：</strong>在此状态下，表示最近收到了从邻居发来的Hello数据包。但是，仍然没有和邻居建立双向通信（Bidirectional Communication），例如，路由器自身并没有出现在邻居发送的Hello数据包中。</li><li><strong>双向通信状态（2-Way）：</strong>此状态意味着两台路由器之间建立了双向通信。在此状态下还将进行DR和BDR的选举（只有处于2-Way状态的路由器才有资格参选DR和BDR）</li><li><strong>信息交换初始状态（ExStart）：</strong>这个状态是建立邻接关系的第一步。该状态的目标是决定信息交换时路由器的主从关系，并确定初始数据库描述（DD）数据包的序列号。具有最高路由器ID的路由器将成为主路由器。</li><li><strong>信息交换状态（ExChange）：</strong>在此状态的路由器通过向邻居发送DD数据包来描述其完整的链路状态数据库。每一个DD数据包都有一个序列号，并且需要被显式的确认。在任何时候，每次只能发送一个DD数据包。在此状态下，路由器也可以发送链路状态请求数据包，用来向邻居请求最新的LSA。实际上，这些状态的邻接关系完全有能力发送和接收所有类型的OSPF协议数据包。</li><li><strong>信息加载状态（Loading）：</strong>在此状态下，路由器将会向邻居路由器发送链路状态请求数据包，用来请求信息交换状态发现的最新的LSA。</li><li><strong>完全邻接状态（Full）：</strong>在此状态下，邻居路由器形成完全邻接关系。这些邻接关系将会在路由器LSA和网络LSA中被描述。</li></ol><h2 id="指定路由器和备份指定路由器"><a href="#指定路由器和备份指定路由器" class="headerlink" title="指定路由器和备份指定路由器"></a>指定路由器和备份指定路由器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>在<u>广播多路访问网络</u>和<u>NBMA</u>网络上会选举<strong>DR(指定路由器)</strong>和<strong>BDR(备份指定路由器)</strong>。</li><li>所有其他路由器只与DR和BDR建立完全邻居关系，其他路由器之间的邻居状态停留在<strong>2-Way状态</strong>。</li><li>所有其他路由器使用组播目的地址 <strong><em>224.0.0.5</em></strong> 向DR和BDR发送链路状态更新。DR 和BDR 使用组播目的地址 <strong><em>224.0.0.6</em></strong> 向区域内所有其他OSPF路由器发送数据包。</li><li>为了避免因DR失效导致的<u>单点故障</u>，多路访问网络上还将选举BDR。DR失效时，BDR将成为DR，由于网络上其他路由器已经和BDR形成了完全邻接关系，因此可以将DR失效对网络的影响降至最低。</li></ul><blockquote><p>DR的概念是将多路访问网络看作一个“伪节点（Pseudo Node）”。当SPF进行计算的时候，<strong>把链路看作一个节点</strong>，与该链路相连的路由器也是连接到这个节点上的。从与伪节点相连的路由器到这个伪节点的代价是该路由器与这个多路访问网络相连的接口的出站代价，从伪节点到任何与之相连的路由器的代价都为0。</p><p>一台路由器可能连接到多个多路访问网络，该路由器可能是它所连接的其中一个多路访问网络的DR，也可能不是它所连接的另一个多路访问网络的DR，也就是说，<strong>DR是路由器接口的属性</strong>，而不是整个路由器的属性。</p></blockquote><h3 id="DR的工作"><a href="#DR的工作" class="headerlink" title="DR的工作"></a>DR的工作</h3><ul><li>描述该多路访问网络和与其相连的路由器。</li><li>管理该多路访问网络上的LSA洪泛扩散过程。</li></ul><h3 id="DR和BDR的相关选举规则"><a href="#DR和BDR的相关选举规则" class="headerlink" title="DR和BDR的相关选举规则"></a>DR和BDR的相关选举规则</h3><ul><li>如果一台OSPF路由器的<strong>接口优先级</strong>（Priority）为0，那么这台路由器永远不能成为DR或BDR。</li><li>具有<strong>最高优先级</strong>的路由器（的接口）将会选举为DR，具有次高优先级的路由器将会选举为BDR。</li><li>如果同时有多台路由器具有相同的优先级，那么具有<strong>最高路由器ID</strong>的路由器将会选举为DR。</li><li>当DR失效时，BDR将成为DR，并将重新选举一个BDR。</li><li>优先级的取值范围为0-255，更高的优先级意味着路由器有更大的机会成为DR。</li><li>如果一台具有更高优先级的路由器在选举完DR和BDR之后接入网络，该路由器将不会成为DR或BDR，直到DR和BDR失效，当DR失效，具有更高优先级的路由器也只会成为BDR。即DR和BDR的选举是<strong>非抢占式</strong>的。</li></ul><h3 id="路由器ID"><a href="#路由器ID" class="headerlink" title="路由器ID"></a>路由器ID</h3><ul><li>路由器标示符， 用于在一个OSPF域中唯一地标识一台路由器， 每台运行OSPF的路由器具备Router-ID；</li><li>OSPF Router-ID的设定可以通过手工配置的方式， 或使用自动获取的方式。 自动选取的机制是： 若路由器存在<u>loopback接口</u>， 则选最大的loopback接口IP地址， 若无则选<u>活跃</u>的物理接口中IP地址最大的作为RouterID；</li><li>Router-ID值遵循稳定第一的原则。</li></ul><h2 id="OSPF的配置"><a href="#OSPF的配置" class="headerlink" title="OSPF的配置"></a>OSPF的配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li><p>开启一个OSPF进程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config)#</span><span class="bash">router ospf process-id</span></span><br></pre></td></tr></table></figure><p>process-id 为OSPF进程号，进程号只具有本地意义</p></li><li><p>宣告特定的网络到OSPF区域</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config-router)#</span><span class="bash">network address wildcard-mask area area-id</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>Wildcard-Mask 通配符掩码——32bit的点分十进制格式表示的掩码。跟子网掩码相反，0 是匹配位，1 是忽略位</li><li><p>查看OSPF邻居表</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router#</span><span class="bash"> show ip ospf neighbor</span></span><br></pre></td></tr></table></figure></li><li><p>查看OSPF LSDB</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router#</span><span class="bash"> show ip ospf database</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>[^1]: <a href="https://zh.wikipedia.org/wiki/开放式最短路径优先#OSPF网络类型" target="_blank" rel="noopener">Open Shortest Path First</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Open Shortest Path First 开放式最短路径优先协议，是用于分配单个自控系统中的路由信息的内部网关协议。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="路由基础" scheme="http://www.theproudsoul.cn/categories/%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>EIGRP</title>
    <link href="http://www.theproudsoul.cn/2019/EIGRP/"/>
    <id>http://www.theproudsoul.cn/2019/EIGRP/</id>
    <published>2019-05-10T16:00:00.000Z</published>
    <updated>2019-05-13T14:05:38.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Enhanced Interior Gateway Routing Protocol  增强型内部网关协议是是增强的距离矢量协议，它依靠<strong>扩散更新算法 (DUAL)</strong> 计算网络中到目标的最短路径。</p><p><a href="https://www.cisco.com/c/zh_cn/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html" target="_blank" rel="noopener">CISCO中文文档</a></p><p><a href="https://www.cisco.com/c/en/us/support/docs/ip/enhanced-interior-gateway-routing-protocol-eigrp/16406-eigrp-toc.html" target="_blank" rel="noopener">CISCO英文文档</a></p><h2 id="EIGRP优点"><a href="#EIGRP优点" class="headerlink" title="EIGRP优点"></a>EIGRP优点</h2><ul><li>在正常工作期间，网络资源的使用率非常低；仅在稳定网络上传输 hello 数据包</li><li>当发生更改时，仅传播路由表更改，而不传播整个路由表；这可减少路由协议自身放在网络上的负载</li><li>可以快速收敛网络拓扑中的更改（在某些情况下，几乎可以瞬间收敛</li></ul><h2 id="EIGRP的三张表"><a href="#EIGRP的三张表" class="headerlink" title="EIGRP的三张表"></a>EIGRP的三张表</h2><ul><li>IP EIGRP Neighbor Table 邻居表——用来存放和邻居路由器相关的数据。</li><li>IP EIGRP Topology Table 拓扑表——用来存放所有从邻居路由器学习到的路径信息。</li><li>The IP Routing Table 路由表——拓扑表中的后继（Successor）会被放入路由表，路由器根据路由表来转发数据包。</li></ul><h2 id="EIGRP数据包"><a href="#EIGRP数据包" class="headerlink" title="EIGRP数据包"></a>EIGRP数据包</h2><ul><li>HELLO分组：以224.0.0.10发送，无需确认Hello包</li><li>更新：只在必要的时候传递必要的信息；以可靠方式发送，需要确认</li><li>查询</li><li>应答：响应查询分组，单播；可靠方式传播</li><li>确认（ACK）</li></ul><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="邻居发现和维护（邻居表）"><a href="#邻居发现和维护（邻居表）" class="headerlink" title="邻居发现和维护（邻居表）"></a>邻居发现和维护（邻居表）</h3><p>为了在整个网络中分配路由信息，EIGRP 使用<strong>非周期性</strong>的<strong>增量</strong>路由更新。（EIGRP 只在这些路径更改时发送有关已更改路径的路由更新）</p><p>只发送路由更新的基本问题是：无法知道邻居路由器是否挂了。EIGRP每隔一定时间就发送hello数据包，这个时间称为<strong>hello间隔</strong>。</p><p>EIGRP 依靠邻居关系在整个网络中<strong>可靠</strong>地传播路由表更改；当两个路由器在公共网络上看到<strong>彼此</strong>的 hello 数据包时，它们成为邻居。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">router#</span> show ip eigrp neighbors</span><br></pre></td></tr></table></figure><h3 id="建立拓扑表"><a href="#建立拓扑表" class="headerlink" title="建立拓扑表"></a>建立拓扑表</h3><p>邻居路由器彼此通信，交换它们的<strong>拓扑表</strong>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">router#</span> show ip eigrp topology</span><br></pre></td></tr></table></figure><p>拓扑表包含建立到每个可达网络的一组距离和矢量所需的信息，包括：</p><ul><li>上游邻居报告的到此目标的路径上的<strong>最低带宽</strong></li><li>总延迟</li><li>路径可靠性</li><li>路径负载</li><li>最短路径最大传输单元 (MTU)</li><li>可行距离</li><li>报告距离</li><li>路由源（外部路由将被标记）</li></ul><h3 id="EIGRP的Metric"><a href="#EIGRP的Metric" class="headerlink" title="EIGRP的Metric"></a>EIGRP的Metric</h3><h4 id="5个标准"><a href="#5个标准" class="headerlink" title="5个标准"></a>5个标准</h4><ul><li>带宽（bandwidth）</li><li>延迟（delay)</li><li>可靠性（reliability)</li><li>负载（loading)</li><li>最大传输单元（MTU)</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>$$<br>[(K1 × Bandwidth + \frac{K2 × Bandwidth}{256 - Load} + K3 × Delay)×(\frac{K5}{Reliability + K4})] × 256<br>$$</p><ul><li><strong>注意：</strong> 如果K5 = 0，公式减少到<br>$$<br>[(K1 × Bandwidth + \frac{K2 × Bandwidth}{256 - Load} + K3 × Delay)] × 256<br>$$</li><li>默认K1 = 1，K2 = 0，K3 = 1，K4 = 0，K5 = 0</li><li>延迟取值沿路所有数据出接口（或路由入口）延迟的累加Delay=延迟(us) / 10 × 256（数据传输方向和路由传输方向相反！！！）</li><li>带宽取值沿路所有数据出接口（或路由入口）带宽的最低值$Bandwidth=[10^7 / 带宽(Kbps)] × 256$</li><li><strong>EIGRP路由Metric默认为 $延迟+带宽$</strong></li><li>EIGRP域内所有路由器的K值都必须设为相同的值</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><strong>Successor 后继路由器</strong>——被实际选中作为到达目标网络所使用的下一跳路由器。</li><li><strong>Fessible Successor 可行后继路由器</strong>——到达该目标网络的备份下一跳路由器（必须满足FC）。</li><li><strong>Advertised Distance 通告距离</strong>——邻居到达目标网络的度量值。</li><li><strong>Feasible Distance 可行距离</strong>——邻居到达目标网络的度量值（ AD）加上本路由器到达该邻居的度量值。</li><li><strong>Feasible Condition 可行性条件</strong>——邻居到达目标网络的度量值（ AD）小于本路由器的FD时，则认为该邻居通告的路径满足FC。</li></ul><h3 id="判定一条路径是否无环路"><a href="#判定一条路径是否无环路" class="headerlink" title="判定一条路径是否无环路"></a>判定一条路径是否无环路</h3><p>DUAL算法：<u><strong>Diffusing Update Algorithm 用于计算最佳无环路径和备用路径</strong></u></p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2yzm95w0tj20j90di0tm.jpg" alt></p><p>关键点：</p><ul><li>关键路径不可用时使用可用后继路径</li><li>无可用后继路径时向邻居求助</li></ul><h3 id="水平分割与毒性逆转"><a href="#水平分割与毒性逆转" class="headerlink" title="水平分割与毒性逆转"></a>水平分割与毒性逆转</h3><ul><li>水平分割规则规定：永远不从通过其获知路由的接口通告该路由。</li><li>毒性逆转规则规定：一旦通过某个接口获知路由，便通过该同一接口将其通告回为不可达路由。</li><li>举例：</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2yw3yburfg209004xwec.gif" alt></p><blockquote><p><em>路由器one</em> 通过一个<strong>多点接口</strong>（如帧中继）连接到 <em>路由器 two和three</em> </p></blockquote><p>水平分割——如果 <em>路由器one</em> 从 <em>路由器 two</em> 获知 <em>网络 A</em>，那么它不会从<strong>同一接口</strong>将到 <em>网络 A</em>  的路由通告回 <em>路由器 3</em>。</p><p>毒性逆转——当 <em>路由器one</em> 从 <em>路由器two</em> 获知网络A时，它会通过其到 <em>路由器two和three</em> 的链路通告 <em>网络A</em> 为<strong>不可达网络</strong>。如果<em>路由器three</em>显示通过 <em>路由器one</em> 到 <em>网络A</em> 的任何路径，它将由于不可达通告删除该路径。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>EIGRP 中有两种汇总形式：自动汇总和手动汇总。</p><h3 id="自动汇总"><a href="#自动汇总" class="headerlink" title="自动汇总"></a>自动汇总</h3><p>EIGRP 每次穿过<strong>两个不同的主类网络之间的边界</strong>时会执行自动汇总。</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2yy5bqbc6g20c90613yd.gif" alt></p><p><em>路由器two</em> 只向 <em>路由器one</em> 通告 10.0.0.0/8 网络，因为 <em>路由器2</em> 用来到达 <em>路由器1</em> 的接口位于不同的<strong>主类网络</strong>中（A类网络和B类网络）。</p><h3 id="手动汇总"><a href="#手动汇总" class="headerlink" title="手动汇总"></a>手动汇总</h3><p>字面意思。。手动配置。。</p><h2 id="EIGRP的配置"><a href="#EIGRP的配置" class="headerlink" title="EIGRP的配置"></a>EIGRP的配置</h2><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li>创建EIGRP进程，并进入路由进程的配置模式</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config)<span class="comment">#router eigrp autonomous-system-num</span></span><br></pre></td></tr></table></figure><p>EIGRP将<em>autonomous-system</em>-num参数称为“自治系统”编号</p><ul><li>在指定的接口上激活EIGRP</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config-router)<span class="comment">#network network-number [wildcard-mask]</span></span><br></pre></td></tr></table></figure><p>如果不加通配符掩码，则自动识别为主类通告，也就是如果键入 <em>network 10.1.1.0</em>，实际为 <em>network 10.0.0.0</em></p><h3 id="查看及排错"><a href="#查看及排错" class="headerlink" title="查看及排错"></a>查看及排错</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>Router#show ip eigrp neighbors</td><td>Displays the neighbors discovered by IP EIGRP</td></tr><tr><td>Router#show ip eigrp topology</td><td>Displays the IP EIGRP topology table</td></tr><tr><td>Router#show ip route eigrp</td><td>Displays current EIGRP entries in the routing table</td></tr><tr><td>Router#show ip protocols</td><td>Displays the parameters and current state of the active routing protocol process</td></tr><tr><td>Router#show ip eigrp traffic</td><td>Displays the number of IP EIGRP packets sent and received</td></tr><tr><td>Router#debug eigrp packet</td><td>Displays all types of EIGRP packets, both sent and received</td></tr><tr><td>Router#debug eigrp neighbor</td><td>Displays the EIGRP neighbor interaction</td></tr><tr><td>Router#debug ip eigrp route</td><td>Displays advertisements and changes EIGRP makes to the routing table</td></tr><tr><td>Router#debug ip eigrp summary</td><td>Displays a brief report of the EIGRP routing activity</td></tr><tr><td>Router#show ip eigrp events</td><td>Displays the different categories of EIGRP activity, including route calculations</td></tr></tbody></table><h2 id="EIGRP负载均衡"><a href="#EIGRP负载均衡" class="headerlink" title="EIGRP负载均衡"></a>EIGRP负载均衡</h2><p>EIGRP 在路由表中最多放置四个<strong>等价路由</strong>，然后路由器将对这些路由进行负载均衡。负载均衡的类型（按数据包或按目标）取决于在路由器中执行的交换的类型。但是，EIGRP 也可以在<strong>非等价链路</strong>上进行负载均衡。</p><h3 id="等价负载均衡"><a href="#等价负载均衡" class="headerlink" title="等价负载均衡"></a>等价负载均衡</h3><ul><li>所谓的等代价路径指的到达同一个目的地度量值相等的路径</li><li>默认最多支持4条等价路径之间进行流量负载，最大可为16条</li></ul><h3 id="非等价负载均衡"><a href="#非等价负载均衡" class="headerlink" title="非等价负载均衡"></a>非等价负载均衡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">Router(config-router)#</span><span class="bash"> Variance multiplier</span></span><br></pre></td></tr></table></figure><p>EIGRP在多条路径上执行非等价负载均衡的条件：</p><ul><li>路由必须是无环的（即满足FC条件： AD&lt;FDmin）</li><li>FD &lt;= FDmin × multiplier（差异值是一个乘数：流量将被放到<u>度量小于最佳路径度量与差异值相乘得到的结果</u>的任何链路上。）</li></ul><h3 id="举栗子——"><a href="#举栗子——" class="headerlink" title="举栗子——"></a>举栗子——</h3><p>假定有四条路径到指定的目标，并且这些路径的度量如下：</p><ul><li>路径 1：1100</li><li>路径 2：1100</li><li>路径 3：2000</li><li>路径 4：4000</li></ul><p>默认情况下，路由器将流量同时放在路径 1 和 2 上。（等价负载均衡）<strong>使用 EIGRP 的 variance 命令来指示路由器同时将流量放在路径 3 和 4 上。</strong>要均衡路径 1、2 和 3 上的负载，可以使用差异值 2，因为 1100 x 2 = 2200，该值大于通过路径 3 的度量。同样地，要同时添加路径 4，需要在 <strong>router eigrp</strong> 命令下发出 variance 4。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Enhanced Interior Gateway Routing Protocol  增强型内部网关协议是是增强的距离矢量协议，它依靠&lt;s
      
    
    </summary>
    
      <category term="路由基础" scheme="http://www.theproudsoul.cn/categories/%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>IP路由基础</title>
    <link href="http://www.theproudsoul.cn/2019/IP%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.theproudsoul.cn/2019/IP路由基础/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-13T14:03:57.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h2><p>路由（routing）是指分组从源到目的地时，决定端到端路径的网络范围的进程。</p><h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>在计算机网络中，<strong>路由表</strong>（routing table）或称<strong>路由择域信息库</strong>（RIB, Routing Information Base），是一个存储在<strong>路由器</strong>或者联网计算机中的电子表格（文件）或类数据库。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的路由度量值）。路由表中含有网络周边的拓扑信息。路由表建立的主要目标是为了实现路由协议和静态路由选择。</p><h3 id="路由表项"><a href="#路由表项" class="headerlink" title="路由表项"></a>路由表项</h3><ul><li>destination：目的地址，用来标识IP包的目的地址或者目的网络。</li><li>mask：网络掩码，与目的地址一起标识目的主机或者路由器所在的网段的地址。</li><li>pre：标识路由加入IP路由表的优先级。可能到达一个目的地有多条路由，但是优先级的存在让他们先选择优先级高的路由进行利用。</li><li>cost：路由开销，当到达一个目的地的多个路由优先级相同时，路由开销最小的将成为最优路由。</li><li>interface：输出接口，说明IP包将从该路由器哪个接口转发。</li><li>nexthop：下一跳IP地址，说明IP包所经过的下一个路由器。</li></ul><h3 id="路由表中有三类路由"><a href="#路由表中有三类路由" class="headerlink" title="路由表中有三类路由"></a>路由表中有三类路由</h3><ol><li>链路层协议发现的路由（即是直连路由）<br>路由器激活接口：1、物理上up；2、协议up</li><li>静态路由</li><li>动态路由协议发现的路由。</li></ol><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2vcj8pul6j20gc0e20yq.jpg" alt></p><h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">R1<span class="comment">#show ip route</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2vcos7mmmj20n20cm41n.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2vd1y1bb5j20n30cdtbs.jpg" alt></p><h2 id="主动路由协议-vs-被动路由协议"><a href="#主动路由协议-vs-被动路由协议" class="headerlink" title="主动路由协议 vs. 被动路由协议"></a>主动路由协议 vs. 被动路由协议</h2><p><u><strong><em>Routed Protocols vs. Routing Protocols</em></strong></u></p><p>被动路由协议（Routed Protocol）是可以使用户数据被路由的协议，比如：IP、IPX、APPLE TALK等。(IP统治世界哈哈哈)</p><p>主动路由协议（Routing Protocol）是用来帮助路由器构建和维护路由表的协议，比如：RIP、OSFP、EIGRP等。</p><h2 id="有类路由协议-vs-无类路由协议"><a href="#有类路由协议-vs-无类路由协议" class="headerlink" title="有类路由协议 vs. 无类路由协议"></a>有类路由协议 vs. 无类路由协议</h2><p><u><strong><em>Classful vs. Classless Routing</em></strong></u></p><h3 id="有类路由协议"><a href="#有类路由协议" class="headerlink" title="有类路由协议"></a>有类路由协议</h3><p><strong>有类路由协议</strong>在更新路由信息的时候<strong>不会携带子网掩码</strong>的信息，常见协议有RIPv1、IGRP。当一个运行有类路由协议的路由收到一个来自其他路由器的路由项：</p><ul><li>如果路由器有<strong>直连接口</strong>与这个路由项属于相同<strong>主网</strong>，则使用这个直连接口的子网掩码作为新路由项的子网掩码。</li><li>如果路由器没有直连接口与这个路由项属于相同<strong>主网</strong>，则使用主网作为子网掩码。</li></ul><blockquote><p> 主网指IP协议的五大类地址A类B类C类D类E类</p></blockquote><p><strong>举栗子——</strong></p><p>以下路由器运行有类路由协议</p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2x3po3qbpj20zg07ggmg.jpg" alt></p><ul><li>路由器B将网段10.2.0.0的路由信息发送给A，但是不会携带子网掩码的信息。</li><li>路由器A发现10.2.0.0属于A类地址<ul><li>假设A有一个<strong>直连接口</strong>连接10.4.0.0/16的网段，10.4.0.0和10.2.0.0同属于A类地址，于是A使用10.4.0.0的子网掩码/16作为10.2.0.0的子网掩码，此时路由器A记下10.2.0.0/16的路由信息。</li><li>假设A没有<strong>直连接口</strong>连接同属于A类地址的网段，于是A使用A类地址的子网掩码/8作为10.2.0.0的子网掩码，此时路由器A记下10.2.0.0/8的路由信息。</li></ul></li></ul><p><u><strong><em>使用有类路由协议时，整个应用范围的网络的子网掩码必须保持一致。</em></strong></u></p><h3 id="无类路由协议"><a href="#无类路由协议" class="headerlink" title="无类路由协议"></a>无类路由协议</h3><p>无类路由协议在路由信息更新时会<strong>携带子网掩码信息</strong>。因此，无类路由协议支持VLSMs（Variable Length Subnet Masks，可变长子网掩码）。常见协议有RIPv2、EIGRP、OSPF 和 IS-IS。</p><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><blockquote><p>通过网络管理员手动配置路由的一种路由方式，就是<strong>静态路由</strong>。</p></blockquote><h3 id="静态路由的配置"><a href="#静态路由的配置" class="headerlink" title="静态路由的配置"></a>静态路由的配置</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="comment">#ip route network-address subnet-mask &#123;ip-add|exit-interface&#125;</span></span><br></pre></td></tr></table></figure><p><strong>举例——</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">R1(config)<span class="comment">#ip route 192.168.1.0 255.255.255.0 192.168.12.2</span></span><br><span class="line">R1(config)<span class="comment">#ip route 192.168.1.0 255.255.255.0 serial0</span></span><br></pre></td></tr></table></figure><p><em>注意：通信是双向的，因此需要注意往返流量。</em></p><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2vz0iurtyj20ro0cgaek.jpg" alt></p><p>R1和R3同时配置好静态路由，R1才能ping通R3，只配置R1无法ping通。</p><h3 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h3><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2vz2rapeoj20s30avq5c.jpg" alt></p><figure class="highlight plain"><figcaption><span>0.0.0.0``` 是匹配所有</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 回环接口</span><br><span class="line"></span><br><span class="line">loopback虚拟接口</span><br><span class="line"></span><br><span class="line">这是一个逻辑接口，真实并不存在</span><br><span class="line"></span><br><span class="line">**举例——**</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line">interface loopback 0</span><br><span class="line">ip address 2.2.2.2 255.255.255.0</span><br></pre></td></tr></table></figure><h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p>常用命令：</p><ul><li>ping——测试连通性</li><li>traceroute——追踪两段中的每一跳</li><li>show ip route——用于显示路由表</li><li>Show ip interface brief——接口信息摘要</li><li>show cdp neighbors detail——用于搜集相邻信息</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>三台路由器R1、R2、R3实现全网互通，并为每一个路由器开启回环接口</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p><em>动态路由</em>是指<em>路由器</em>能够自动地建立自己的<em>路由</em>表，并且能够根据实际情况的变化适时地进行调整。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>配置简单</li><li>当网络拓扑变更时，能够自动收敛</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>占用CPU和内存资源</li><li>路由信息的交流占用网络带宽</li></ol><h3 id="动态路由协议的分类"><a href="#动态路由协议的分类" class="headerlink" title="动态路由协议的分类"></a>动态路由协议的分类</h3><pre class="mermaid">graph TD    动态路由协议 --> 内部网关协议    动态路由协议 --> 外部网关协议    内部网关协议 --> 距离矢量协议    内部网关协议 --> 链路状态协议    距离矢量协议 --> RIPv1    距离矢量协议 --> IGRP    RIPv1 --> RIPv2    IGRP --> EIGRP    链路状态协议 --> OSPF    链路状态协议 --> IS-IS</pre><h3 id="距离矢量路由选择协议"><a href="#距离矢量路由选择协议" class="headerlink" title="距离矢量路由选择协议"></a>距离矢量路由选择协议</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>周期性泛洪整张路由表</li><li>依照传闻的更新</li><li>逐跳更新</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>路由初始启动</li><li>随着更新周期交换路由信息</li><li>收敛完成——当所有路由表包含相同的网络可达性信息，网络（路由）进入一个稳态</li></ul><h4 id="度量值Metric"><a href="#度量值Metric" class="headerlink" title="度量值Metric"></a>度量值Metric</h4><blockquote><p>Metric值优的装进路由表，Metric值次的放入后台备用，Metric值相同的负载均衡</p></blockquote><ul><li>RIP——跳数</li><li>RIP度量值的查看</li></ul><p><img src="http://ww1.sinaimg.cn/large/7b19d4ddgy1g2wbxnksxoj20r50e142w.jpg" alt></p><blockquote><p>1前面的<strong>120</strong>指的是<strong>管理距离（AD值）</strong></p></blockquote><h4 id="环路的产生"><a href="#环路的产生" class="headerlink" title="环路的产生"></a>环路的产生</h4><!--待完成举例--><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>​        路由环路是指数据包在一系列路由器之间不断传输却始终无法到达其预期目的网络的一种现象。当两台或多台路由器的路由信息中存在错误地指向不可达目的网络的有效路径时，就可能发生路由环路。（一般是由<u>距离矢量路由协议</u>引发的）</p><h5 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h5><ol><li>静态路由配置错误</li><li>路由重分布配置错误</li><li>发生了改变的网络中收敛速度缓慢，不一致的路由表未能得到更新</li><li>错误配置或添加了丢弃的路由</li></ol><h5 id="消除机制"><a href="#消除机制" class="headerlink" title="消除机制"></a>消除机制</h5><ul><li><strong>定义最大度量值以防止计数至无穷大</strong></li><li><strong>水平分割 Split Horizon</strong>——路由器不能使用接收更新的同一接口来通告同一网络。</li><li><strong>毒性路由Route Poisoning</strong>——当路由器感知到某个网段发生故障，可以立即泛洪该网段的路由（ 将其跳数设置为16跳，也就是不可达），以此来快速刷新网络中其他路由器的路由表。</li><li><strong>毒性反转Poison Reverse</strong>——</li><li><strong>抑制计时器Hold-Down Timers</strong><ul><li>为正在重新收敛的网络增加了应变能力</li><li>引入了某种程度的怀疑量</li></ul></li><li><strong>触发更新Triggered Updates</strong>——拓扑发生变更时，路由器立即发送更新消息，而不等更新计时器超时</li></ul><h3 id="管理距离（AD值）"><a href="#管理距离（AD值）" class="headerlink" title="管理距离（AD值）"></a>管理距离（AD值）</h3><blockquote><ul><li>英文：administrative distance</li><li>缩写：AD</li><li>管理距离是指一种<strong>路由协议的路由可信度</strong>。每一种路由协议按可靠性从高到低，依次分配一个信任等级，这个信任等级就叫管理距离。</li><li>对于两种不同的路由协议到一个目的地的路由信息，路由器首先根据管理距离决定相信哪一个协议。</li><li>小值优先</li></ul></blockquote><table><thead><tr><th>Routing Protocols</th><th>AD</th><th>备注</th></tr></thead><tbody><tr><td>直连接口</td><td>0</td><td></td></tr><tr><td>关联出接口的静态路由</td><td>1</td><td>Metric =0</td></tr><tr><td>关联下一跳的静态路由</td><td>1</td><td>Metric =0</td></tr><tr><td>EIGRP 汇总路由</td><td>5</td><td></td></tr><tr><td>外部 BGP</td><td>20</td><td></td></tr><tr><td>内部EIGRP</td><td>90</td><td></td></tr><tr><td>IGRP</td><td>100</td><td></td></tr><tr><td>OSPF</td><td>110</td><td></td></tr><tr><td>RIPv1、v2</td><td>120</td><td></td></tr><tr><td>外部EIGRP</td><td>170</td><td></td></tr><tr><td>内部BGP</td><td>200</td></tr></tbody></table><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>最大上限15跳（16跳为不可达）——极大程度上限制了RIP所能支持的网络规模</p><ul><li>RIP（Routing Information Protocol，路由信息协议）是应用较早、使用较普遍的内部网关协议（Interior Gateway Protocol，简称IGP）</li><li>适用于小型同类网络，是典型的距离矢量协议</li><li>是基于UDP，端口520的应用层协议</li><li>管理距离：120</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>启动RIP路由选择进程</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config)<span class="comment">#router rip</span></span><br></pre></td></tr></table></figure><ul><li>宣告指定的直连网络（接口）</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Router(config-router)<span class="comment">#network network-number</span></span><br></pre></td></tr></table></figure><h2 id="补充：FIB（转发信息库）"><a href="#补充：FIB（转发信息库）" class="headerlink" title="补充：FIB（转发信息库）"></a>补充：FIB（转发信息库）</h2><p>RIB表把所有路由协议学习到的路由汇总到一起，经过优选，把<strong>优选结果</strong>的路由加入到FIB表，供转发使用。所以FIB是RIB的一个子集。</p>]]></content>
    
    <summary type="html">
    
      路由协议入门知识
    
    </summary>
    
      <category term="路由基础" scheme="http://www.theproudsoul.cn/categories/%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
